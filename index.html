// Voeg deze variabelen toe bovenaan je script (bij de andere lets)
let ghostChaseStart = false;
let chaseStartTime = 0;
let gameStartTime = 0;

// Vervang de initLevel functie door deze versie:
function initLevel() {
    dots = []; walls = [];
    
    for(let y=0; y<11; y++) for(let x=0; x<19; x++) {
        if(mazeLayout[y][x] === 1) walls.push({x, y});
        else if(mazeLayout[y][x] === 0) dots.push({x, y, eaten: false});
    }
    
    pacman.x = 9; pacman.y = 9; pacman.dir = {x:0, y:0}; pacman.nextDir = {x:0, y:0};
    ghosts = [
        {x:9, y:5, color:'red', speed: 0.04, path: []},
        {x:8, y:5, color:'pink', speed: 0.035, path: []}
    ];
    
    ghostChaseStart = false;
    gameStartTime = Date.now();
    chaseStartTime = 0;
}

// Vervang de gameLoop functie door deze verbeterde versie:
function gameLoop() {
    if(!inGame) return;
    
    frame++; 
    ctx.fillStyle = '#000'; 
    ctx.fillRect(0,0,canvas.width,canvas.height);
    
    // Check of 20 seconden zijn verstreken
    const elapsedTime = Date.now() - gameStartTime;
    if (!ghostChaseStart && elapsedTime > 20000) {
        ghostChaseStart = true;
        chaseStartTime = Date.now();
    }
    
    // Teken muren
    ctx.fillStyle = '#0022aa'; 
    ctx.strokeStyle = '#00ffff'; 
    ctx.lineWidth = 2;
    walls.forEach(w => { 
        ctx.fillRect(w.x*tileSize+2, w.y*tileSize+2, tileSize-4, tileSize-4); 
        ctx.strokeRect(w.x*tileSize+1, w.y*tileSize+1, tileSize-2, tileSize-2); 
    });
    
    // Teken stippen
    ctx.fillStyle = '#fff'; 
    dots.forEach(d => { 
        if(!d.eaten){ 
            ctx.beginPath(); 
            ctx.arc(d.x*tileSize+tileSize/2, d.y*tileSize+tileSize/2, 2, 0, 7); 
            ctx.fill(); 
        }
    });
    
    // Teleport Tunnel Logica voor Pac-Man
    if(pacman.x < -0.5) pacman.x = 18.5; 
    if(pacman.x > 18.5) pacman.x = -0.5;
    
    // Pac-Man beweging en score
    if(Number.isInteger(pacman.x) && Number.isInteger(pacman.y)) {
        let d = dots.find(dot => dot.x === pacman.x && dot.y === pacman.y && !dot.eaten);
        if(d){ 
            d.eaten = true; 
            score += 10; 
            document.getElementById('scr-val').innerText = score; 
            sRef.update({score}); 
        }
        if(canMove(pacman.x+pacman.nextDir.x, pacman.y+pacman.nextDir.y)) pacman.dir = pacman.nextDir;
        if(!canMove(pacman.x+pacman.dir.x, pacman.y+pacman.dir.y)) pacman.dir = {x:0, y:0};
        
        if(pacman.dir.x === 1) pacman.rotation = 0; 
        else if(pacman.dir.x === -1) pacman.rotation = Math.PI;
        else if(pacman.dir.y === 1) pacman.rotation = Math.PI/2; 
        else if(pacman.dir.y === -1) pacman.rotation = -Math.PI/2;
    }
    
    pacman.x = Math.round((pacman.x + pacman.dir.x*0.1)*10)/10; 
    pacman.y = Math.round((pacman.y + pacman.dir.y*0.1)*10)/10;
    
    // Teken Pac-Man
    ctx.save(); 
    ctx.translate(pacman.x*tileSize+tileSize/2, pacman.y*tileSize+tileSize/2); 
    ctx.rotate(pacman.rotation);
    ctx.fillStyle = 'yellow'; 
    ctx.beginPath(); 
    let mouth = Math.abs(Math.sin(frame*0.2)) * 0.25;
    ctx.arc(0, 0, tileSize/2-2, (0.2 + mouth) * Math.PI, (1.8 - mouth) * Math.PI); 
    ctx.lineTo(0,0); 
    ctx.fill(); 
    ctx.restore();
    
    // Timer display
    let diff = Math.floor((20000 - (Date.now() - levelStartTime)) / 1000);
    const chaseTime = ghostChaseStart ? Math.floor((Date.now() - chaseStartTime) / 1000) : 0;
    document.getElementById('timer-display').innerText = 
        powerTimer > 0 ? "âš¡ GHOST HUNT âš¡" : 
        ghostChaseStart ? `ðŸ‘» CHASE MODE (${chaseTime}s)` : 
        (diff > 0 ? `ðŸš¨ WAARSCHUWING (${diff}s)` : "ðŸƒ ACTIE!");
    
    // Update en teken spookjes
    ghosts.forEach(g => {
        // Teleport tunnel voor spookjes
        if(g.x < -0.5) g.x = 18.5; 
        if(g.x > 18.5) g.x = -0.5;
        
        // Ghost AI: jagen na 20 seconden
        if (ghostChaseStart && powerTimer <= 0) {
            // Update pad naar Pac-Man
            updateGhostPath(g);
            
            // Volg het pad
            if (g.path && g.path.length > 0) {
                const target = g.path[0];
                const dx = target.x - g.x;
                const dy = target.y - g.y;
                
                if (Math.abs(dx) > 0.1) {
                    g.x += Math.sign(dx) * g.speed;
                } else if (Math.abs(dy) > 0.1) {
                    g.y += Math.sign(dy) * g.speed;
                } else {
                    // Bereikt knooppunt, verwijder uit pad
                    g.path.shift();
                }
            }
        } else {
            // Normale beweging voor de eerste 20 seconden
            const directions = [
                {x: 1, y: 0}, {x: -1, y: 0}, 
                {x: 0, y: 1}, {x: 0, y: -1}
            ];
            
            // Kies een willekeurige richting die mogelijk is
            const possibleDirs = directions.filter(dir => 
                canMove(g.x + dir.x, g.y + dir.y)
            );
            
            if (possibleDirs.length > 0) {
                const dir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                g.x += dir.x * g.speed * 0.5; // Langzamer bewegen voor de eerste 20s
                g.y += dir.y * g.speed * 0.5;
            }
        }
        
        // Teken het spookje
        ctx.fillStyle = powerTimer > 0 ? 'blue' : g.color;
        ctx.globalAlpha = (ghostChaseStart && powerTimer <= 0) ? 1 : 0.3;
        
        ctx.beginPath(); 
        ctx.arc(g.x*tileSize+tileSize/2, g.y*tileSize+tileSize/2, tileSize/2-2, 0, 7); 
        ctx.fill(); 
        ctx.globalAlpha = 1;
        
        // Botsingsdetectie
        if(Math.hypot(pacman.x - g.x, pacman.y - g.y) < 0.7) {
            if(powerTimer > 0) { 
                g.x = 9; 
                g.y = 5; 
                g.path = [];
                score += 200; 
                document.getElementById('scr-val').innerText = score;
                sRef.update({score});
            } else if(ghostChaseStart) { 
                levens--; 
                document.getElementById('lvn-val').innerText = levens; 
                if(levens <= 0) { 
                    inGame=false; 
                    document.getElementById('quiz-box').style.display='block'; 
                    document.getElementById('vraag').innerText = "GAME OVER"; 
                    document.getElementById('restart-btn').style.display='block'; 
                } else startQuiz(5); 
            }
        }
    });
    
    if(powerTimer > 0) powerTimer--;
    requestAnimationFrame(gameLoop);
}

// Nieuwe functie voor pathfinding
function updateGhostPath(ghost) {
    // BFS algoritme voor eenvoudige pathfinding
    const start = {x: Math.round(ghost.x), y: Math.round(ghost.y)};
    const target = {x: Math.round(pacman.x), y: Math.round(pacman.y)};
    
    // Als ghost al op Pac-Man's positie is, clear path
    if (start.x === target.x && start.y === target.y) {
        ghost.path = [];
        return;
    }
    
    // BFS queue
    const queue = [{pos: start, path: []}];
    const visited = new Set();
    visited.add(`${start.x},${start.y}`);
    
    const directions = [
        {x: 1, y: 0}, {x: -1, y: 0},
        {x: 0, y: 1}, {x: 0, y: -1}
    ];
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        for (const dir of directions) {
            const nextX = current.pos.x + dir.x;
            const nextY = current.pos.y + dir.y;
            
            // Check of de volgende positie geldig is
            if (!canMove(nextX, nextY)) continue;
            
            const nextKey = `${nextX},${nextY}`;
            if (visited.has(nextKey)) continue;
            
            visited.add(nextKey);
            const newPath = [...current.path, {x: nextX, y: nextY}];
            
            // Check of we Pac-Man hebben bereikt
            if (nextX === target.x && nextY === target.y) {
                ghost.path = newPath;
                return;
            }
            
            queue.push({pos: {x: nextX, y: nextY}, path: newPath});
        }
    }
    
    // Als er geen pad gevonden wordt, clear path
    ghost.path = [];
}

// Helper functie om te checken of beweging mogelijk is
function canMove(x, y) {
    // Teleport tunnel (rij 5)
    if (y === 5 && (x < 0 || x > 18)) return true;
    
    // Buiten het doolhof
    if (x < 0 || x > 18 || y < 0 || y > 10) return false;
    
    // Check muren
    return !walls.some(w => w.x === Math.round(x) && w.y === Math.round(y));
}
