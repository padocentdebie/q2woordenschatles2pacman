<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man: Ghost Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #111;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            color: white;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            border: 4px solid #222;
            box-shadow: 0 0 20px rgba(0,0,255,0.3);
            background-color: black;
            max-width: 100%;
        }
        .stats {
            margin-bottom: 10px;
            font-size: 1.5rem;
            display: flex;
            gap: 20px;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
            color: #888;
        }
    </style>
</head>
<body>

    <div class="stats">
        <div>Score: <span id="score">0</span></div>
        <div>Levens: <span id="lives">3</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="controls">
        Gebruik de <b>Pijltjestoetsen</b> om te bewegen<br>
        Eet de grote bollen om de spoken te kunnen vangen!
    </div>

    <!-- Game Over Overlay -->
    <div id="overlay" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center hidden flex-col">
        <h1 id="status-text" class="text-6xl font-bold mb-8 text-yellow-400">GAME OVER</h1>
        <button onclick="resetGame()" class="px-8 py-3 bg-blue-600 hover:bg-blue-700 rounded-full text-xl transition">Opnieuw Spelen</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const overlay = document.getElementById('overlay');
        const statusText = document.getElementById('status-text');

        const TILE_SIZE = 24;
        const GRID_WIDTH = 19;
        const GRID_HEIGHT = 21;

        canvas.width = TILE_SIZE * GRID_WIDTH;
        canvas.height = TILE_SIZE * GRID_HEIGHT;

        // 0: Pad, 1: Muur, 2: Puntje, 3: Power Pellet, 4: Ghost Home
        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1],
            [0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0],
            [1,1,1,1,2,1,0,1,1,4,1,1,0,1,2,1,1,1,1],
            [0,0,0,0,2,0,0,1,4,4,4,1,0,0,2,0,0,0,0],
            [1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1],
            [0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0],
            [1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,0,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let currentMap = [];
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let powerMode = 0; // Timer voor power mode

        const pacman = {
            x: 9 * TILE_SIZE + TILE_SIZE/2,
            y: 15 * TILE_SIZE + TILE_SIZE/2,
            dir: 0, // 0: Right, 1: Down, 2: Left, 3: Up
            nextDir: 0,
            speed: 2,
            mouth: 0,
            mouthSpeed: 0.1
        };

        const ghosts = [
            { x: 9 * TILE_SIZE + TILE_SIZE/2, y: 9 * TILE_SIZE + TILE_SIZE/2, color: '#FF0000', dir: 3, speed: 1.5, state: 'normal', name: 'Blinky' },
            { x: 8 * TILE_SIZE + TILE_SIZE/2, y: 9 * TILE_SIZE + TILE_SIZE/2, color: '#FFB8FF', dir: 3, speed: 1.5, state: 'normal', name: 'Pinky' },
            { x: 10 * TILE_SIZE + TILE_SIZE/2, y: 9 * TILE_SIZE + TILE_SIZE/2, color: '#00FFFF', dir: 3, speed: 1.5, state: 'normal', name: 'Inky' },
            { x: 9 * TILE_SIZE + TILE_SIZE/2, y: 8 * TILE_SIZE + TILE_SIZE/2, color: '#FFB852', dir: 3, speed: 1.5, state: 'normal', name: 'Clyde' }
        ];

        function resetMap() {
            currentMap = JSON.parse(JSON.stringify(map));
        }

        function resetPositions() {
            pacman.x = 9 * TILE_SIZE + TILE_SIZE/2;
            pacman.y = 15 * TILE_SIZE + TILE_SIZE/2;
            pacman.dir = 0;
            pacman.nextDir = 0;
            
            ghosts.forEach((g, i) => {
                g.x = (8 + (i % 3)) * TILE_SIZE + TILE_SIZE/2;
                g.y = 9 * TILE_SIZE + TILE_SIZE/2;
                g.state = 'normal';
            });
        }

        function resetGame() {
            score = 0;
            lives = 3;
            gameOver = false;
            powerMode = 0;
            scoreElement.innerText = score;
            livesElement.innerText = lives;
            overlay.classList.add('hidden');
            resetMap();
            resetPositions();
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') pacman.nextDir = 0;
            if (e.key === 'ArrowDown') pacman.nextDir = 1;
            if (e.key === 'ArrowLeft') pacman.nextDir = 2;
            if (e.key === 'ArrowUp') pacman.nextDir = 3;
        });

        function canMove(x, y, dir) {
            let nextX = x;
            let nextY = y;
            const buffer = 10; // Collision buffer

            if (dir === 0) nextX += buffer;
            if (dir === 1) nextY += buffer;
            if (dir === 2) nextX -= buffer;
            if (dir === 3) nextY -= buffer;

            const col = Math.floor(nextX / TILE_SIZE);
            const row = Math.floor(nextY / TILE_SIZE);

            if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) return false;
            const tile = currentMap[row][col];
            return tile !== 1 && tile !== 4; // 1 is muur, 4 is spookhuis deur
        }

        function moveEntity(entity) {
            // Probeer van richting te veranderen
            if (entity === pacman && entity.dir !== entity.nextDir) {
                // Alleen op het midden van een tile draaien voor betere controle
                const centerX = Math.floor(entity.x / TILE_SIZE) * TILE_SIZE + TILE_SIZE/2;
                const centerY = Math.floor(entity.y / TILE_SIZE) * TILE_SIZE + TILE_SIZE/2;
                
                if (Math.abs(entity.x - centerX) < 4 && Math.abs(entity.y - centerY) < 4) {
                    if (canMove(centerX, centerY, entity.nextDir)) {
                        entity.x = centerX;
                        entity.y = centerY;
                        entity.dir = entity.nextDir;
                    }
                }
            }

            // Beweging
            let moveX = 0, moveY = 0;
            if (entity.dir === 0) moveX = entity.speed;
            if (entity.dir === 1) moveY = entity.speed;
            if (entity.dir === 2) moveX = -entity.speed;
            if (entity.dir === 3) moveY = -entity.speed;

            if (canMove(entity.x + moveX, entity.y + moveY, entity.dir)) {
                entity.x += moveX;
                entity.y += moveY;
            } else if (entity !== pacman) {
                // Spoken kiezen een nieuwe willekeurige richting bij botsing
                entity.dir = Math.floor(Math.random() * 4);
            }

            // Screen wrap-around
            if (entity.x < 0) entity.x = canvas.width;
            if (entity.x > canvas.width) entity.x = 0;
        }

        function updateGhosts() {
            ghosts.forEach(ghost => {
                // Simpele AI: als in powerMode, vlucht. Anders, beweeg random of volg een beetje.
                if (Math.random() < 0.02) { // Af en toe van koers veranderen
                    const directions = [0, 1, 2, 3];
                    ghost.dir = directions[Math.floor(Math.random() * 4)];
                }
                
                ghost.speed = (powerMode > 0 && ghost.state !== 'eaten') ? 0.8 : 1.5;
                moveEntity(ghost);

                // Check collision met Pac-Man
                const dist = Math.hypot(pacman.x - ghost.x, pacman.y - ghost.y);
                if (dist < TILE_SIZE * 0.8) {
                    if (powerMode > 0) {
                        if (ghost.state !== 'eaten') {
                            ghost.state = 'eaten';
                            score += 200;
                            scoreElement.innerText = score;
                        }
                    } else if (ghost.state !== 'eaten') {
                        lives--;
                        livesElement.innerText = lives;
                        if (lives <= 0) {
                            gameOver = true;
                        } else {
                            resetPositions();
                        }
                    }
                }
            });
        }

        function drawMap() {
            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    const tile = currentMap[r][c];
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;

                    if (tile === 1) {
                        ctx.fillStyle = '#2222FF';
                        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    } else if (tile === 2) {
                        ctx.fillStyle = '#FFB8AE';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tile === 3) {
                        ctx.fillStyle = '#FFB8AE';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPacman() {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            const centerX = pacman.x;
            const centerY = pacman.y;
            const radius = TILE_SIZE / 2 - 2;
            
            // Mond animatie
            pacman.mouth += pacman.mouthSpeed;
            if (pacman.mouth > 0.2 || pacman.mouth < 0) pacman.mouthSpeed *= -1;

            const rotation = pacman.dir * (Math.PI / 2);
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, rotation + pacman.mouth, rotation + (2 * Math.PI) - pacman.mouth);
            ctx.fill();
        }

        function drawGhosts() {
            ghosts.forEach(ghost => {
                ctx.fillStyle = (powerMode > 0 && ghost.state !== 'eaten') ? (powerMode < 100 && Math.floor(Date.now()/200)%2 ? 'white' : '#2121ff') : ghost.color;
                if (ghost.state === 'eaten') ctx.fillStyle = 'rgba(255,255,255,0.2)';

                const x = ghost.x - TILE_SIZE/2 + 2;
                const y = ghost.y - TILE_SIZE/2 + 2;
                const size = TILE_SIZE - 4;

                // Lichaam spook
                ctx.beginPath();
                ctx.arc(x + size/2, y + size/2, size/2, Math.PI, 0);
                ctx.lineTo(x + size, y + size);
                // Golvende onderkant
                for(let i=0; i<3; i++) {
                    ctx.lineTo(x + size - (i*size/3) - size/6, y + size - 4);
                    ctx.lineTo(x + size - (i*size/3) - size/3, y + size);
                }
                ctx.lineTo(x, y + size/2);
                ctx.fill();

                // Ogen
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x + size*0.3, y + size*0.4, 3, 0, Math.PI*2);
                ctx.arc(x + size*0.7, y + size*0.4, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(x + size*0.3, y + size*0.4, 1.5, 0, Math.PI*2);
                ctx.arc(x + size*0.7, y + size*0.4, 1.5, 0, Math.PI*2);
                ctx.fill();
            });
        }

        function gameLoop() {
            if (gameOver) {
                statusText.innerText = "GAME OVER";
                overlay.classList.remove('hidden');
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            moveEntity(pacman);
            updateGhosts();

            // Eet check
            const col = Math.floor(pacman.x / TILE_SIZE);
            const row = Math.floor(pacman.y / TILE_SIZE);
            if (currentMap[row][col] === 2) {
                currentMap[row][col] = 0;
                score += 10;
                scoreElement.innerText = score;
            } else if (currentMap[row][col] === 3) {
                currentMap[row][col] = 0;
                score += 50;
                powerMode = 500; // Frames van power mode
                scoreElement.innerText = score;
            }

            if (powerMode > 0) powerMode--;
            if (powerMode === 0) {
                ghosts.forEach(g => g.state = 'normal');
            }

            // Win check
            if (!currentMap.some(row => row.includes(2) || row.includes(3))) {
                statusText.innerText = "GEWONNEN!";
                statusText.className = "text-6xl font-bold mb-8 text-green-400";
                overlay.classList.remove('hidden');
                return;
            }

            drawMap();
            drawPacman();
            drawGhosts();

            requestAnimationFrame(gameLoop);
        }

        resetMap();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
